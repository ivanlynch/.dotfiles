#!/usr/bin/env bash

set -euo pipefail

# Color codes
readonly NC='\033[0m'
readonly GREEN='\033[00;32m'
readonly RED='\033[00;31m'
readonly CYAN='\033[00;36m'
readonly SEA="\\033[38;5;49m"
readonly LBLACK='\033[01;30m'
readonly LRED='\033[01;31m'
readonly LGREEN='\033[01;32m'
readonly OVERWRITE='\e[1A\e[K'

# Emoji codes
readonly ARROW="${SEA}\xE2\x96\xB6${NC}"
readonly XMARK="${RED}\xE2\x9C\x96${NC}"
readonly CHECK="${GREEN}\xE2\x9C\x94${NC}"

# Constants
readonly DOTFILESLOG="$HOME/.dotfiles.log"
readonly DOTFILESDIR="$HOME/.dotfiles"
readonly BACKUP_DIR="$HOME/.dotfiles-backup"

# Función para mostrar tareas con mejor manejo de errores
task() {
    if [[ -n "${TASK:-}" ]]; then
        printf "%b%b [ ]  %b%b\n" "${OVERWRITE}" "${LGREEN}" "${LGREEN}" "${TASK}"
    fi
    TASK=$1
    printf "%b [ ]  %s \n%b" "${LBLACK}" "${TASK}" "${LRED}"
}

# Función para marcar tareas como completadas
task_done() {
    if [[ -n "${TASK:-}" ]]; then
        printf "%b%b [%b]  %b%b\n" "${OVERWRITE}" "${LGREEN}" "${CHECK}" "${LGREEN}" "${TASK}" "${NC}"
        unset TASK
    fi
}

# Función mejorada para ejecutar comandos con mejor logging
cmd() {
    local command="$1"
    local log_file="${DOTFILESLOG}"
    
    # Asegurar que el archivo de log existe
    touch "${log_file}"
    > "${log_file}"
    
    if eval "${command}" 1> /dev/null 2> "${log_file}"; then
        return 0
    fi
    
    printf "%b%b [X]  %s%b\n" "${OVERWRITE}" "${LRED}" "${TASK}" "${LRED}"
    while IFS= read -r line; do
        printf "      %s\n" "${line}"
    done < "${log_file}"
    printf "\n"
    rm "${log_file}"
    exit 1
}

# Función para gestionar dotfiles con mejor manejo de errores
config() {
    git --git-dir="${DOTFILESDIR}/.git" --work-tree="${HOME}" "$@"
}

# Función para realizar backup de manera segura
backup_file() {
    local file="$1"
    local backup_path="${BACKUP_DIR}/${file}"
    
    if [[ -e "${HOME}/${file}" ]]; then
        mkdir -p "$(dirname "${backup_path}")"
        cp -R "${HOME}/${file}" "${backup_path}"
        return 0
    fi
    return 1
}

# Función para verificar si hay cambios en el repositorio
check_repo_changes() {
    local current_commit
    local remote_commit
    
    current_commit=$(git -C "${DOTFILESDIR}" rev-parse HEAD)
    git -C "${DOTFILESDIR}" fetch --quiet
    remote_commit=$(git -C "${DOTFILESDIR}" rev-parse @{u})
    
    if [[ "${current_commit}" == "${remote_commit}" ]]; then
        return 1
    fi
    return 0
}

# Detección de sistema operativo

detect_os() {
    case "$OSTYPE" in
        linux-gnu*)
            if grep -qi microsoft /proc/version 2>/dev/null; then
                OS="wsl"
            else
                OS="linux"
            fi
            ;;
        darwin*)
            OS="mac"
            ;;
        cygwin*|msys*|win32*)
            OS="windows"
            ;;
        *)
            OS="unknown"
            ;;
    esac
}

detect_os

# Verificación del sistema
if [[ "$OS" == "mac" ]]; then
    : # No action needed for Mac
elif [[ "$OS" == "linux" ]]; then
    task "Installing Ansible"
    cmd "export DEBIAN_FRONTEND=noninteractive"
    cmd "apt-get update"
    cmd "apt-get upgrade -y"
    cmd "apt-get install -y ansible"
    task_done
elif [[ "$OS" == "wsl" ]]; then
    task "Detectado Windows Subsystem for Linux (WSL)"
    # Instalar openssh-client si no está instalado
    if ! command -v ssh >/dev/null 2>&1; then
        cmd "apt-get update"
        cmd "apt-get install -y openssh-client"
    fi
    # Generar clave SSH si no existe
    if [[ ! -f "$HOME/.ssh/id_ed25519" ]]; then
        task "Generando clave SSH para GitHub"
        ssh-keygen -t ed25519 -C "$(whoami)@$(hostname)" -f "$HOME/.ssh/id_ed25519" -N ""
        task_done
    fi
    # Mostrar la clave pública para agregar a GitHub
    task "Agrega esta clave pública a GitHub (https://github.com/settings/ssh/new):"
    cat "$HOME/.ssh/id_ed25519.pub"
    echo
    task_done
    task_done
elif [[ "$OS" == "windows" ]]; then
    task "Detectado Windows nativo"
    # Puedes agregar comandos específicos para Windows aquí
    task_done
else
    echo -e "${XMARK} ${RED}Sistema operativo no soportado${NC}"
    exit 1
fi

# Gestión del repositorio
if ! [[ -d "${DOTFILESDIR}" ]]; then
    task "Cloning repository"
    # Usar SSH en vez de HTTPS si estamos en WSL
    if [[ "$OS" == "wsl" ]]; then
        cmd "git clone --quiet --bare git@github.com:ivanlynch/.dotfiles.git ${DOTFILESDIR}"
    else
        cmd "git clone --quiet --bare https://github.com/ivanlynch/.dotfiles.git ${DOTFILESDIR}"
    fi
    task_done
else
    if check_repo_changes; then
        task "Updating repository"
        cmd "git -C ${DOTFILESDIR} pull --quiet"
        task_done
    else
        echo -e "${ARROW} ${CYAN}Tu configuración está actualizada${NC}"
        exit 0
    fi
fi

# Backup y checkout
task "Realizando backup de la configuración existente"
mkdir -p "${BACKUP_DIR}"

# Identificar y respaldar archivos que serán sobrescritos
config checkout 2>&1 | grep -E "^\s+\." | awk '{print $1}' | while IFS= read -r file; do
    if backup_file "${file}"; then
        echo "  Respaldando ${file} a .dotfiles-backup/"
    fi
done
task_done

# Checkout de dotfiles (sobrescribir configuración)
task "Aplicando nueva configuración"
config checkout -f
config config status.showUntrackedFiles no
task_done

echo -e "${ARROW} ${CYAN}Instalación completa! Tu configuración anterior ha sido respaldada en ${BACKUP_DIR}${NC}"