#!/usr/bin/env bash

set -euo pipefail

# Color codes
readonly NC='\033[0m'
readonly GREEN='\033[00;32m'
readonly RED='\033[00;31m'
readonly CYAN='\033[00;36m'
readonly SEA="\\033[38;5;49m"
readonly LBLACK='\033[01;30m'
readonly LRED='\033[01;31m'
readonly LGREEN='\033[01;32m'
readonly OVERWRITE='\e[1A\e[K'

# Emoji codes
readonly ARROW="${SEA}\xE2\x96\xB6${NC}"
readonly XMARK="${RED}\xE2\x9C\x96${NC}"
readonly CHECK="${GREEN}\xE2\x9C\x94${NC}"

# Constants
readonly DOTFILESLOG="$HOME/.dotfiles.log"
readonly DOTFILESDIR="$HOME/.dotfiles"
readonly BACKUP_DIR="$HOME/.dotfiles-backup"

# Función para mostrar tareas con mejor manejo de errores
task() {
    if [[ -n "${TASK:-}" ]]; then
        printf "%b%b [ ]  %b%b\n" "${OVERWRITE}" "${LGREEN}" "${LGREEN}" "${TASK}"
    fi
    TASK=$1
    printf "%b [ ]  %s \n%b" "${LBLACK}" "${TASK}" "${LRED}"
}

# Función para marcar tareas como completadas
task_done() {
    if [[ -n "${TASK:-}" ]]; then
        printf "%b%b [%b]  %b%b\n" "${OVERWRITE}" "${LGREEN}" "${CHECK}" "${LGREEN}" "${TASK}" "${NC}"
        unset TASK
    fi
}

# Función mejorada para ejecutar comandos con mejor logging
cmd() {
    local command="$1"
    local log_file="${DOTFILESLOG}"
    
    # Asegurar que el archivo de log existe
    touch "${log_file}"
    > "${log_file}"
    
    if eval "${command}" 1> /dev/null 2> "${log_file}"; then
        return 0
    fi
    
    printf "%b%b [X]  %s%b\n" "${OVERWRITE}" "${LRED}" "${TASK}" "${LRED}"
    while IFS= read -r line; do
        printf "      %s\n" "${line}"
    done < "${log_file}"
    printf "\n"
    rm "${log_file}"
    exit 1
}

# Función para gestionar dotfiles con mejor manejo de errores
config() {
    git --git-dir="${DOTFILESDIR}/.git" --work-tree="${HOME}" "$@"
}

# Función para realizar backup de manera segura
backup_file() {
    local file="$1"
    local backup_path="${BACKUP_DIR}/${file}"
    
    if [[ -e "${HOME}/${file}" ]]; then
        mkdir -p "$(dirname "${backup_path}")"
        cp -R "${HOME}/${file}" "${backup_path}"
        return 0
    fi
    return 1
}

# Función para verificar si hay cambios en el repositorio
check_repo_changes() {
    local current_commit
    local remote_commit
    
    current_commit=$(git -C "${DOTFILESDIR}" rev-parse HEAD)
    git -C "${DOTFILESDIR}" fetch --quiet
    remote_commit=$(git -C "${DOTFILESDIR}" rev-parse @{u})
    
    if [[ "${current_commit}" == "${remote_commit}" ]]; then
        return 1
    fi
    return 0
}

# Función para configurar el perfil de PowerShell
configure_powershell() {
    # Crear directorios necesarios
    mkdir -p "$HOME/.config/powershell"
    
    # Crear archivo de perfil si no existe
    if [[ ! -f "$HOME/.config/powershell/profile.ps1" ]]; then
        echo "# PowerShell Profile configurado por dotfiles" > "$HOME/.config/powershell/profile.ps1"
        echo "Write-Host 'Perfil cargado desde .config/powershell/profile.ps1' -ForegroundColor Green" >> "$HOME/.config/powershell/profile.ps1"
    fi
    
    # Determinar la ruta del perfil de PowerShell
    local ps_profile_path="$HOME/Documents/WindowsPowerShell"
    local ps_core_path="$HOME/Documents/PowerShell"
    
    # Configurar Windows PowerShell (5.1)
    mkdir -p "$ps_profile_path"
    echo ". `$env:USERPROFILE\\.config\\powershell\\profile.ps1" > "$ps_profile_path/profile.ps1"
    
    # Configurar PowerShell Core (6+)
    mkdir -p "$ps_core_path"
    echo ". `$env:USERPROFILE\\.config\\powershell\\profile.ps1" > "$ps_core_path/profile.ps1"
    
    # Configurar Windows Terminal si existe
    local wt_settings="$HOME/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json"
    local wt_settings_alt="$HOME/AppData/Local/Microsoft/Windows Terminal/settings.json"
    
    if [[ -f "$wt_settings" ]] || [[ -f "$wt_settings_alt" ]]; then
        task "Configurando Windows Terminal"
        
        local settings_file=""
        if [[ -f "$wt_settings" ]]; then
            settings_file="$wt_settings"
        else
            settings_file="$wt_settings_alt"
        fi
        
        # Hacer backup del archivo de configuración
        cp "$settings_file" "$BACKUP_DIR/windows_terminal_settings.json"
        
        # Modificar la configuración con PowerShell
        powershell.exe -NoProfile -Command "
            \$settings = Get-Content -Path '$settings_file' -Raw | ConvertFrom-Json;
            \$powershell_profile = \$settings.profiles.list | Where-Object { \$_.name -eq 'Windows PowerShell' -or \$_.name -eq 'PowerShell' };
            if (\$powershell_profile) {
                foreach(\$profile in \$powershell_profile) {
                    \$profile.commandline = 'powershell.exe -NoLogo -NoExit -Command . \"\$env:USERPROFILE\\.config\\powershell\\profile.ps1\"';
                }
                \$settings | ConvertTo-Json -Depth 32 | Set-Content -Path '$settings_file';
                Write-Host 'Configuracion de Windows Terminal actualizada correctamente.';
            } else {
                Write-Host 'No se encontró un perfil de PowerShell en Windows Terminal.';
            }
        "
        task_done
    fi
}

# Detección de sistema operativo

detect_os() {
    case "$OSTYPE" in
        linux-gnu*)
            if grep -qi microsoft /proc/version 2>/dev/null; then
                OS="wsl"
            else
                OS="linux"
            fi
            ;;
        darwin*)
            OS="mac"
            ;;
        cygwin*|msys*|win32*)
            OS="windows"
            ;;
        *)
            OS="unknown"
            ;;
    esac
}

detect_os

# Verificación del sistema
if [[ "$OS" == "mac" ]]; then
    : # No action needed for Mac
elif [[ "$OS" == "linux" ]]; then
    task "Installing Ansible"
    cmd "export DEBIAN_FRONTEND=noninteractive"
    cmd "apt-get update"
    cmd "apt-get upgrade -y"
    cmd "apt-get install -y ansible"
    task_done
elif [[ "$OS" == "wsl" ]]; then
    task "Detectado Windows Subsystem for Linux (WSL)"
    # Instalar openssh-client si no está instalado
    if ! command -v ssh >/dev/null 2>&1; then
        cmd "apt-get update"
        cmd "apt-get install -y openssh-client"
    fi
    # Generar clave SSH si no existe
    if [[ ! -f "$HOME/.ssh/id_ed25519" ]]; then
        task "Generando clave SSH para GitHub"
        ssh-keygen -t ed25519 -C "$(whoami)@$(hostname)" -f "$HOME/.ssh/id_ed25519" -N ""
        task_done
    fi
    # Mostrar la clave pública para agregar a GitHub
    task "Agrega esta clave pública a GitHub (https://github.com/settings/ssh/new):"
    cat "$HOME/.ssh/id_ed25519.pub"
    echo
    task_done
    task_done
elif [[ "$OS" == "windows" ]]; then
    task "Detectado Windows nativo"
    # Verificar si PowerShell está disponible
    if command -v powershell.exe >/dev/null 2>&1; then
        task "Configurando perfil de PowerShell en .config"
        configure_powershell
        task_done
    else
        echo -e "${ARROW} ${CYAN}PowerShell no encontrado. Saltando configuración de PowerShell.${NC}"
    fi
    task_done
else
    echo -e "${XMARK} ${RED}Sistema operativo no soportado${NC}"
    exit 1
fi

# Gestión del repositorio
if ! [[ -d "${DOTFILESDIR}" ]]; then
    task "Cloning repository"
    # Usar SSH en vez de HTTPS si estamos en WSL
    if [[ "$OS" == "wsl" ]]; then
        cmd "git clone --quiet --bare git@github.com:ivanlynch/.dotfiles.git ${DOTFILESDIR}"
    else
        cmd "git clone --quiet --bare https://github.com/ivanlynch/.dotfiles.git ${DOTFILESDIR}"
    fi
    task_done
else
    if check_repo_changes; then
        task "Updating repository"
        cmd "git -C ${DOTFILESDIR} pull --quiet"
        task_done
    else
        echo -e "${ARROW} ${CYAN}Tu configuración está actualizada${NC}"
        exit 0
    fi
fi

# Backup y checkout
task "Realizando backup de la configuración existente"
mkdir -p "${BACKUP_DIR}"

# Identificar y respaldar archivos que serán sobrescritos
config checkout 2>&1 | grep -E "^\s+\." | awk '{print $1}' | while IFS= read -r file; do
    if backup_file "${file}"; then
        echo "  Respaldando ${file} a .dotfiles-backup/"
    fi
done
task_done

# Checkout de dotfiles (sobrescribir configuración)
task "Aplicando nueva configuración"
config checkout -f
config config status.showUntrackedFiles no
task_done

echo -e "${ARROW} ${CYAN}Instalación completa! Tu configuración anterior ha sido respaldada en ${BACKUP_DIR}${NC}"